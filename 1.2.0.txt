settings
{
	main
	{
		Description: "Project: Phantom. Survive the nightmare until time runs out! Choose from multiple and unique survivors to help both yourself and your teammates. Version 1.2.0. Created by Block#12425. Discord server: https://discord.gg/CSKSVDH"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Max Team 1 Players: 1
		Max Team 2 Players: 9
		Return To Lobby: Never
		Team Balancing: After A Game
	}

	modes
	{
		Team Deathmatch
		{
			enabled maps
			{
				Ecopoint: Antarctica
				Eichenwalde Halloween
				Necropolis
			}
		}

		General
		{
			Hero Limit: 2 Per Team
			Self Initiated Respawn: Off
			Skins: Off
			Spawn Health Packs: Disabled
		}
	}

	heroes
	{
		Team 1
		{
			Reaper
			{
				Damage Dealt: 500%
				Damage Received: 10%
				Movement Speed: 110%
				Primary Fire: Off
				Shadow Step: Off
				Ultimate Ability Death Blossom: Off
			}

			enabled heroes
			{
				Reaper
			}
		}

		Team 2
		{
			Quick Melee: Off

			Brigitte
			{
				Barrier Shield Cooldown Time: 20%
				Barrier Shield Recharge Rate: 150%
				Healing Dealt: 10%
				Primary Fire: Off
				Repair Pack: Off
				Ultimate Ability Rally: Off
				Whip Shot Knockback Scalar: 150%
			}

			Hanzo
			{
				Primary Fire: Off
				Sonic Arrow: Off
				Storm Arrows: Off
				Ultimate Ability Dragonstrike: Off
			}

			Moira
			{
				Biotic Orb: Off
				Primary Fire: Off
				Secondary Fire: Off
				Ultimate Ability Coalescence: Off
			}

			Reaper
			{
				Damage Dealt: 350%
				Damage Received: 10%
			}

			Symmetra
			{
				Primary Fire: Off
				Secondary Fire: Off
				Sentry Turret Cooldown Time: 150%
				Ultimate Ability Photon Barrier: Off
			}

			Tracer
			{
				Blink Cooldown Time: 400%
				Primary Fire: Off
				Ultimate Ability Pulse Bomb: Off
			}

			Winston
			{
				Barrier Projector: Off
				Primary Fire: Off
				Ultimate Ability Primal Rage: Off
			}

			Wrecking Ball
			{
				Grappling Claw: Off
				Infinite Ultimate Duration: On
				Minefield Knockback Scalar: 200%
				Piledriver: Off
				Primary Fire: Off
				Projectile Gravity: 150%
				Projectile Speed: 150%
				Roll: Off
				Spawn With Ultimate Ready: On
				Ultimate Generation - Combat Minefield: 0%
				Ultimate Generation - Passive Minefield: 500%
				Ultimate Generation Minefield: 100%
			}

			Zenyatta
			{
				Orb of Discord: Off
				Primary Fire: Off
				Quick Melee: Off
				Secondary Fire: Off
				Spawn With Ultimate Ready: On
				Ultimate Generation - Passive Transcendence: 500%
			}

			enabled heroes
			{
				Brigitte
				Hanzo
				Moira
				Symmetra
				Tracer
				Winston
				Wrecking Ball
			}
		}

		General
		{
			Widowmaker
			{
				Grappling Hook: Off
				Infinite Ultimate Duration: On
				Primary Fire: Off
				Quick Melee: Off
				Spawn With Ultimate Ready: On
				Venom Mine: Off
			}
		}
	}
}

variables
{
	global:
		0: stringVersion
		1: stringCreator
		2: stringDiscord
		3: stringDiscordLink
		4: stringProject
		5: stringProjectLink
		6: stringCreatorVersion
		7: stringCodeLink
		8: stringCode
		9: stringSec
		10: stringHP
		11: stringMoiraTitle
		12: stringMoiraAbility1
		13: stringMoiraAbility2
		14: stringMoiraPassive
		15: stringMoiraHeal
		16: stringMoiraSacrifice
		17: stringHideInfo
		18: stringShowInfo
		19: stringHanzoTitle
		20: stringHanzoAbility1
		21: stringHanzoAbility2
		22: stringHanzoPassive
		23: stringBrigTitle
		24: stringBrigAbility1
		25: stringBrigAbility2
		26: stringWBTitle
		27: stringWBAbility1
		28: stringWBAbility2
		29: stringCharges
		30: stringSymTitle
		31: stringSymAbility1
		32: stringSymAbility2
		33: stringTracerTitle
		34: stringTracerAbility1
		35: stringTracerAbility2
		36: stringReaperTitle
		37: stringReaperAbility1
		38: stringReaperAbility2
		39: stringReaperAbility3
		40: stringReaperAbility4
		41: stringReaperAbility5
		42: stringTracerPassive
		43: stringWinstonTitle
		44: stringWinstonAbility1
		45: stringWinstonAbility2
		46: stringTracerTeleportMessage
		47: stringTeamKill
		48: stringWinstonGrab
		49: stringTimeRemaining
		50: stringObjectiveSurvivors
		51: stringObjectiveReaper
		52: stringReaperTeleport
		53: stringReaperTeleportGhost
		54: stringLateJoin
		55: stringChase
		56: stringTip
		57: stringReaperTeleportSpawn
		58: stringArrayFog
		59: stringGhost
		60: stringWinstonRide
		61: stringOneHit
		62: stringWaitingGame
		63: stringGH
		64: stringGHDiscord
		65: stringGHDiscordLink
		66: stringReaperHit
		67: stringTip2
		68: stringInvalidPosition
		69: hudIDs
		70: effectIDs
		71: inWorldTextIDs
		72: iconIDs
		73: i
		74: j
		75: fogDistance
		76: gracePeriod
		77: matchTimeMin
		78: matchTimeSec
		79: constantMatchTime
		80: debugMode
		81: tipsEnabled
		82: dynMatchTime

	player:
		0: survivorSpecificVariable3
		1: survivorSpecificVariable4
		2: winstonGrab
		3: lateJoin
		4: survivorSpecificVariable
		5: throwingPlayer
		6: survivorSpecificVariable2
		8: hasSpawned
		9: hideInfo
		10: survivorSpecificVariable5
		11: prevHero
		12: k
}

subroutines
{
	1: commonSub
	2: playerReset
	3: fogCreation
	4: debugMode
	5: nameTagCreate
}

rule("Constant Strings")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.stringCodeLink = Custom String("8MM16");
		Global.stringProjectLink = Custom String("workshop.codes/8MM16");
		Global.stringDiscordLink = Custom String("discord.gg/CSKSVDH");
		Global.stringVersion = Custom String("1.2.0");
		Global.stringCreator = Custom String("Block#12425");
		Global.stringGHDiscordLink = Custom String("grandeurhammers.com");
	}
}

rule("Determine Language (English)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"By default all strings are set to English. If it is a different language then the strings will be set to that, with any untranslated strings remaining in English.\r\n\nAll strings (that will be translated if they are) for the game."
		Global.stringProject = Custom String("Project: {0}", Global.stringProjectLink);
		Global.stringDiscord = Custom String("Discord: {0} (All caps)", Global.stringDiscordLink);
		Global.stringCreatorVersion = Custom String("Created by: {0}. Version: {1}", Global.stringCreator, Global.stringVersion);
		Global.stringCode = Custom String("Code: {0}", Global.stringCodeLink);
		Global.stringSec = Custom String("CD");
		Global.stringHP = Custom String("HP");
		Global.stringMoiraTitle = Custom String("Moira, the phasing support.");
		Global.stringMoiraAbility1 = Custom String("Fade out and go through walls to escape.");
		Global.stringMoiraAbility2 = Custom String("Heal an injured teammate for 1 HP. Does not work on Tracer.");
		Global.stringHideInfo = Custom String("Hide Info.");
		Global.stringShowInfo = Custom String("Show info");
		Global.stringHanzoTitle = Custom String("Hanzo, the eagle-eye.");
		Global.stringHanzoAbility1 = Custom String("Leap in the air.");
		Global.stringHanzoAbility2 = Custom String("Climb up walls.");
		Global.stringHanzoPassive = Custom String("Passive: Less Fog. Pings the Phantom and tracks it when he sees it.");
		Global.stringBrigTitle = Custom String("Brigitte, the frontline resistance.");
		Global.stringBrigAbility1 = Custom String("Use flail to throw the Phantom back.");
		Global.stringBrigAbility2 = Custom String("Bash and stun with the shield! Requires primary fire to use.\nDoes not block damage.");
		Global.stringWBTitle = Custom String("Wrecking Ball, the area denier");
		Global.stringWBAbility1 = Custom String("Create a force field that repels the Phantom,\neven in when he is in Wraith form.");
		Global.stringWBAbility2 = Custom String(
			"Place a mine field that lasts infinitely (and can be destroyed).\n The Phantom will be stunned and knocked back if he hits one.");
		Global.stringCharges = Custom String("Charges");
		Global.stringTracerTitle = Custom String("Tracer, the quick-save speedster.");
		Global.stringTracerAbility1 = Custom String("Cover a chunk of distance in your current velocity instantly.");
		Global.stringTracerAbility2 = Custom String(
			"Rewind to your position 3 seconds ago. Any teammates within\nthe ring when used will also be warped to your position.");
		Global.stringReaperTitle = Custom String("Reaper, the monstrous spirit.");
		Global.stringReaperAbility1 = Custom String("Go into wraith form to go faster and go through walls.");
		Global.stringReaperAbility2 = Custom String("Enter teleport mode, able to fly and spawn back (you or your ghost) anywhere.");
		Global.stringReaperAbility3 = Custom String("Spawn a ghost, that appears just like you and roams the map.");
		Global.stringReaperAbility4 = Custom String("Swap positions with your ghost, perfectly in the same direction as each other.");
		Global.stringReaperAbility5 = Custom String(
			"Punch survivors close enough to deal damage. Targets are usually\ntwo hits, unless buffed by Moira.");
		Global.stringSymTitle = Custom String("Symmetra, the team escort.");
		Global.stringSymAbility1 = Custom String("Place a turret that slows down the Phantom. Can be destroyed. Max 3.");
		Global.stringSymAbility2 = Custom String(
			"Create a teleporter for teammates to use. Use same button to destroy.\nWhen destroyed, restores charges of turrets.");
		Global.stringTracerPassive = Custom String("Passive: Fragile. (1 hit only)");
		Global.stringWinstonTitle = Custom String("Winston, the relocating ape.");
		Global.stringWinstonAbility1 = Custom String("Leap a far distance, along with anyone else you are carrying.");
		Global.stringWinstonAbility2 = Custom String(
			"When holding no one, pick up a teammate within range (the ring).\nWhen holding someone, throw them in your current facing d{0}",
			Custom String("irection."));
		Global.stringTracerTeleportMessage = Custom String("Teleported you back to safety my love!");
		Global.stringMoiraHeal = Custom String("I have healed you.");
		Global.stringMoiraSacrifice = Custom String("I have sacrificed my life for you all! Do not fail me.");
		Global.stringTeamKill = Custom String("Nice job, you killed a teammate. Now you're dead.");
		Global.stringWinstonGrab = Custom String("I have picked you up! I can throw you far distances for your safety!");
		Global.stringTimeRemaining = Custom String("Time Remaining");
		Global.stringObjectiveSurvivors = Custom String("Survive until time runs out!");
		Global.stringObjectiveReaper = Custom String("Kill all the mortals before time runs out!");
		Global.stringReaperTeleport = Custom String("Finish Teleporting");
		Global.stringReaperTeleportGhost = Custom String("Spawn a ghost");
		Global.stringLateJoin = Custom String("Joined mid-match. Please wait until next match!");
		Global.stringTip = Custom String("Tip: Only one REAL Phantom exists. Hanzo pings phantoms.");
		Global.stringTip2 = Custom String("Tip: Wrecking Ball's mines can be deactivated with melee.");
		Global.stringReaperTeleportSpawn = Custom String("You think you can hide...");
		Global.stringArrayFog = Array(Custom String("A ghostly fog settles in..."), Custom String("A snow storm forms..."), Custom String(
			"A dust storm rolls in..."));
		Global.stringWinstonRide = Custom String("Hop off of Winston");
		Global.stringGhost = Custom String("Ghost");
		Global.stringChase = Custom String("Chasing survivor...");
		Global.stringOneHit = Custom String("Only one hit left!");
		Global.stringWaitingGame = Custom String("Please have the host start the game");
		Global.stringMoiraPassive = Custom String("Passive: You can see teammates in the fog & their health status.");
		Global.stringGH = Custom String("{0} Certified by Grandeur Hammers", Ability Icon String(Hero(Torbjörn), Button(Ability 2)));
		Global.stringGHDiscord = Custom String("{0}", Global.stringGHDiscordLink);
		Global.stringReaperHit = Custom String("Successful hit! Recharging...");
		Global.stringInvalidPosition = Custom String("Teleported into an invalid position!");
	}
}

rule("Player Workshop Setting Variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.fogDistance = Workshop Setting Integer(Custom String("General"), Custom String("Fog Distance"), 14, 5, 30, 0);
	}
}

rule("Team 2 Game Start Setup")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Wait(0.500, Abort When False);
		"Unique fog messages for each map."
		If(Current Map == Map(Ecopoint: Antarctica));
			Small Message(Event Player, Global.stringArrayFog[1]);
		Else If(Current Map == Map(Necropolis));
			Small Message(Event Player, Global.stringArrayFog[2]);
		Else;
			Small Message(Event Player, First Of(Global.stringArrayFog));
		End;
		"Team 2 players cannot see where they are."
		Start Forcing Player Outlines(Players In Slot(0, Team 1), All Players(Team 2), False, Color(White), Default);
		Disable Nameplates(Players In Slot(0, Team 1), All Players(All Teams));
		Start Forcing Player Outlines(Players In Slot(2, Team 1), All Players(Team 2), False, Color(White), Default);
		Disable Nameplates(Players In Slot(2, Team 1), All Players(All Teams));
		Start Forcing Player Outlines(Event Player, All Players(Team 2), False, Color(White), Default);
		Disable Nameplates(Event Player, All Players(Team 2));
		Start Scaling Player(Event Player, 0.900, True);
		Start Scaling Barriers(Event Player, 0.900, True);
		If(Is Game In Progress);
			Disable Built-In Game Mode Respawning(Event Player);
			Big Message(Event Player, Global.stringObjectiveSurvivors);
	}
}

rule("Common Subroutine")
{
	event
	{
		Subroutine;
		commonSub;
	}

	actions
	{
		"This fog is unique to the player, that way they always see fogDistance meters ahead of them."
		If(Hero Of(Event Player) != Hero(Hanzo));
			Call Subroutine(fogCreation);
		End;
		Wait(0.500, Ignore Condition);
		Heal(Event Player, Null, 1000);
		Wait(1, Ignore Condition);
		Set Healing Dealt(Event Player, 0);
		Event Player.prevHero = Hero Of(Event Player);
		Start Forcing Player Outlines(Players In Slot(0, Team 1), Event Player, False, Color(White), Default);
		Disable Nameplates(Players In Slot(0, Team 1), All Players(All Teams));
		Start Forcing Player Outlines(Players In Slot(2, Team 1), Event Player, False, Color(White), Default);
		Disable Nameplates(Players In Slot(2, Team 1), All Players(All Teams));
		Start Forcing Player Outlines(Event Player, All Players(Team 2), False, Color(White), Default);
		Disable Nameplates(Event Player, All Players(Team 2));
	}
}

rule("Fog Creation Subroutine")
{
	event
	{
		Subroutine;
		fogCreation;
	}

	actions
	{
		Create Effect(Event Player, Bad Aura, Color(Black), Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
			Event Player) * Global.fogDistance), 1000, Visible To Position and Radius);
		Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
		Create Effect(Event Player, Bad Aura, Color(Black), Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
			Event Player) * (Global.fogDistance + 1)), 1000, Visible To Position and Radius);
		Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
		Create Effect(Event Player, Bad Aura, Color(Black), Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
			Event Player) * (Global.fogDistance + 2)), 1000, Visible To Position and Radius);
		Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
		Create Effect(Event Player, Bad Aura, Color(Black), Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
			Event Player) * Global.fogDistance * -1), 1000, Visible To Position and Radius);
		Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
	}
}

rule("Player Dies due to teammate")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.throwingPlayer != Null;
		Attacker != Players In Slot(0, Team 1);
	}

	actions
	{
		"If a troll was successful, this makes sure that the player trolled is not punished, but instead the troll. This only works with Winston and Tracer."
		Kill(Event Player.throwingPlayer, Event Player);
		Small Message(Event Player.throwingPlayer, Global.stringTeamKill);
		Event Player.throwingPlayer = Null;
		Wait(0.200, Ignore Condition);
		Respawn(Event Player);
	}
}

rule("Reset Player Throw Status")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is On Ground(Event Player) == True;
		Event Player.throwingPlayer != Null;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Event Player.throwingPlayer = Null;
	}
}

rule("Hide Info HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		If(Event Player.hideInfo == False);
			Event Player.hideInfo = True;
		Else;
			Event Player.hideInfo = False;
	}
}

rule("Player Clean-up Team 2")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	actions
	{
		For Global Variable(i, 0, 8, 1);
			If(!Entity Exists(Players In Slot(Global.i, Team 2)));
				For Global Variable(j, 0, Count Of(Global.hudIDs[Global.i]), 1);
					Destroy HUD Text(Global.hudIDs[Global.i][Global.j]);
					Global.hudIDs[Global.i] = Empty Array;
				End;
				For Global Variable(j, 0, Count Of(Global.effectIDs[Global.i]), 1);
					Destroy Effect(Global.effectIDs[Global.i][Global.j]);
					Global.effectIDs[Global.i] = Empty Array;
				End;
				For Global Variable(j, 0, Count Of(Global.inWorldTextIDs[Global.i]), 1);
					Destroy In-World Text(Global.inWorldTextIDs[Global.i][Global.j]);
					Global.inWorldTextIDs[Global.i] = Empty Array;
				End;
				For Global Variable(j, 0, Count Of(Global.iconIDs[Global.i]), 1);
					Destroy In-World Text(Global.iconIDs[Global.i][Global.j]);
					Global.iconIDs[Global.i] = Empty Array;
				End;
			End;
		End;
	}
}

rule("Assembly Players Team 2 Clean-Up")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		For Global Variable(i, 0, 8, 1);
			For Global Variable(j, 0, Count Of(Global.hudIDs[Global.i]), 1);
				Destroy HUD Text(Global.hudIDs[Global.i][Global.j]);
			End;
			Global.hudIDs[Global.i] = Empty Array;
			For Global Variable(j, 0, Count Of(Global.effectIDs[Global.i]), 1);
				Destroy Effect(Global.effectIDs[Global.i][Global.j]);
			End;
			Global.effectIDs[Global.i] = Empty Array;
			For Global Variable(j, 0, Count Of(Global.inWorldTextIDs[Global.i]), 1);
				Destroy In-World Text(Global.inWorldTextIDs[Global.i][Global.j]);
			End;
			Global.inWorldTextIDs[Global.i] = Empty Array;
			For Global Variable(j, 0, Count Of(Global.iconIDs[Global.i]), 1);
				Destroy In-World Text(Global.iconIDs[Global.i][Global.j]);
			End;
			Global.iconIDs[Global.i] = Empty Array;
			Remove All Health Pools From Player(Players In Slot(Global.i, Team 2));
		End;
	}
}

rule("Player Reset")
{
	event
	{
		Subroutine;
		playerReset;
	}

	actions
	{
		For Player Variable(Event Player, k, 0, Count Of(Global.hudIDs[Slot Of(Event Player)]), 1);
			Destroy HUD Text(Global.hudIDs[Slot Of(Event Player)][Event Player.k]);
		End;
		Global.hudIDs[Slot Of(Event Player)] = Empty Array;
		For Player Variable(Event Player, k, 0, Count Of(Global.effectIDs[Slot Of(Event Player)]), 1);
			Destroy Effect(Global.effectIDs[Slot Of(Event Player)][Event Player.k]);
		End;
		Global.effectIDs[Slot Of(Event Player)] = Empty Array;
		For Player Variable(Event Player, k, 0, Count Of(Global.inWorldTextIDs[Slot Of(Event Player)]), 1);
			Destroy In-World Text(Global.inWorldTextIDs[Slot Of(Event Player)][Event Player.k]);
		End;
		Global.inWorldTextIDs[Slot Of(Event Player)] = Empty Array;
		For Player Variable(Event Player, k, 0, Count Of(Global.iconIDs[Slot Of(Event Player)]), 1);
			Destroy Icon(Global.iconIDs[Slot Of(Event Player)][Event Player.k]);
		End;
		Global.iconIDs[Slot Of(Event Player)] = Empty Array;
		Remove All Health Pools From Player(Event Player);
		Set Gravity(Event Player, 100);
		Wait(0.016, Ignore Condition);
		Set Max Health(Event Player, 100);
		Create HUD Text(Event Player, Custom String("{0}: {1}", Icon String(Heart), Round To Integer(Health(Event Player) / 150, Up)),
			Health(Event Player) <= 150 ? Global.stringOneHit : Custom String(""), Null, Top, 0.500, Health(Event Player) > 150 ? Color(
			Green) : Color(Red), Color(White), Null, Visible To String and Color, Default Visibility);
		Modify Global Variable At Index(hudIDs, Slot Of(Event Player), Append To Array, Last Text ID);
	}
}

rule("Winston Grab Reset")
{
	event
	{
		Player Left Match;
		Team 2;
		All;
	}

	conditions
	{
		Entity Exists(Event Player.throwingPlayer) == False;
		Event Player.winstonGrab != False;
	}

	actions
	{
		Detach Players(Event Player);
		Event Player.winstonGrab = False;
		Clear Status(Event Player, Hacked);
	}
}

rule("Brigitte Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Is Game In Progress || Is Waiting For Players) == True;
		Has Spawned(Event Player) == True;
		Event Player.lateJoin == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(Hero Of(Event Player) != Event Player.prevHero || Event Player.prevHero == Null);
			Call Subroutine(playerReset);
			Wait(0.100, Ignore Condition);
			Create HUD Text(Event Player, Custom String("{0}\n{1}", Custom String("{0} : {1}", Ability Icon String(Hero(Brigitte), Button(
				Ability 1)), Custom String("{0} {1}", Round To Integer(Ability Cooldown(Event Player, Button(Ability 1)), Up),
				Global.stringSec)), Custom String("{0}: {1}", Ability Icon String(Hero(Brigitte), Button(Secondary Fire)), Custom String(
				"{0} {1}", Round To Integer(Ability Cooldown(Event Player, Button(Primary Fire)), Up), Global.stringSec))), Null, Null, Left,
				0, Color(Yellow), Null, Null, Visible To and String, Default Visibility);
			Modify Global Variable At Index(hudIDs, Slot Of(Event Player), Append To Array, Last Text ID);
			Set Max Health(Event Player, 20 / Max Health(Event Player) * 100);
			Add Health Pool To Player(Event Player, Health, 180, True, True);
			Call Subroutine(commonSub);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
	}
}

rule("Using Shield Bash")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Primary Fire)) > 0;
	}

	actions
	{
		"To counter balancing patches."
		Set Ability Cooldown(Event Player, Button(Primary Fire), 7);
	}
}

rule("Using Flail")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Brigitte;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == False;
		Event Player.hasSpawned == True;
	}

	actions
	{
		"To counter balancing patches."
		Set Ability Cooldown(Event Player, Button(Ability 1), 4);
	}
}

rule("Moira Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Is Game In Progress || Is Waiting For Players) == True;
		Has Spawned(Event Player) == True;
		Event Player.lateJoin == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(Hero Of(Event Player) != Event Player.prevHero || Event Player.prevHero == Null);
			Call Subroutine(playerReset);
			Wait(0.100, Ignore Condition);
			Create HUD Text(Event Player, Custom String("{0}\n{1}", Custom String("{0}: {1}", Ability Icon String(Hero(Moira), Button(
				Ability 1)), Custom String("{0} {1}", Round To Integer(Ability Cooldown(Event Player, Button(Ability 1)), Up),
				Global.stringSec)), Custom String("{0}: {1}", Ability Icon String(Hero(Zenyatta), Button(Ability 1)), Custom String("{0} {1}",
				Round To Integer(Ability Cooldown(Event Player, Button(Ability 2)), Up), Global.stringSec))), Null, Null, Left, 0, Color(
				Purple), Null, Null, Visible To and String, Default Visibility);
			Modify Global Variable At Index(hudIDs, Slot Of(Event Player), Append To Array, Last Text ID);
			Set Max Health(Event Player, 200 / Max Health(Event Player) * 100);
			Call Subroutine(commonSub);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Create Icon(Is In Line of Sight(Event Player, Player Closest To Reticle(Event Player, Team 2), Barriers Do Not Block LOS)
				&& Is In View Angle(Event Player, Player Closest To Reticle(Event Player, Team 2), 20) && Health(Player Closest To Reticle(
				Event Player, Team 2)) < Max Health(Player Closest To Reticle(Event Player, Team 2)) && Is Alive(Player Closest To Reticle(
				Event Player, Team 2)) ? Event Player : Empty Array, Player Closest To Reticle(Event Player, Team 2), Heart,
				Visible To and Position, Color(Green), False);
			Modify Global Variable At Index(iconIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
	}
}

rule("Moira Clipping I")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"Like Reaper, Moira can no clip too, but to prevent exploits she is also teleported to NWP when she is done, to prevent hiding outside the map or in the environment."
		Disable Movement Collision With Environment(Event Player, False);
	}
}

rule("Moira Clipping II")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Enable Movement Collision With Environment(Event Player);
		Teleport(Event Player, Nearest Walkable Position(Position Of(Event Player)));
		"Cooldown is manually set to counter balancing patches."
		Set Ability Cooldown(Event Player, Button(Ability 1), 9);
	}
}

rule("Moira Healing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Moira;
	}

	conditions
	{
		Is In Line of Sight(Event Player, Player Closest To Reticle(Event Player, Team 2), Barriers Do Not Block LOS) == True;
		Is In View Angle(Event Player, Player Closest To Reticle(Event Player, Team 2), 20) == True;
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Health(Player Closest To Reticle(Event Player, Team 2)) < Max Health(Player Closest To Reticle(Event Player, Team 2)) - 20;
		Is Alive(Player Closest To Reticle(Event Player, Team 2)) == True;
		Is Alive(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		"Moira's healing is unique. She takes a chunk of her health pool to heal someone else. However, she can die during this process."
		Event Player.survivorSpecificVariable = Player Closest To Reticle(Event Player, Team 2);
		Heal(Event Player.survivorSpecificVariable, Event Player, 150);
		Small Message(Event Player.survivorSpecificVariable, Custom String("{0} {1}: {2}", Hero Icon String(Hero(Moira)), Event Player,
			Global.stringMoiraHeal));
		If(Event Player.survivorSpecificVariable != Null);
			Play Effect(All Players(All Teams), Good Explosion, Color(Green), Event Player.survivorSpecificVariable, 2);
			Set Ability Cooldown(Event Player, Button(Ability 2), 60);
	}
}

rule("Winston Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Is Game In Progress || Is Waiting For Players) == True;
		Has Spawned(Event Player) == True;
		Event Player.lateJoin == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(Hero Of(Event Player) != Event Player.prevHero || Event Player.prevHero == Null);
			Call Subroutine(playerReset);
			Wait(0.100, Ignore Condition);
			Create HUD Text(Event Player, Custom String("{0}\n{1}", Custom String("{0} : {1}", Ability Icon String(Hero(Winston), Button(
				Ability 1)), Custom String("{0} {1}", Round To Integer(Ability Cooldown(Event Player, Button(Ability 1)), Up),
				Global.stringSec)), Custom String("{0}: {1}", Ability Icon String(Hero(Mercy), Button(Ability 2)), Custom String("{0} {1}",
				Round To Integer(Ability Cooldown(Event Player, Button(Ability 2)), Up), Global.stringSec))), Null, Null, Left, 0, Color(
				White), Null, Null, Visible To and String, Default Visibility);
			Modify Global Variable At Index(hudIDs, Slot Of(Event Player), Append To Array, Last Text ID);
			Create Effect(Event Player, Ring, Color(White), Update Every Frame(Position Of(Event Player)), 6, Visible To Position and Radius);
			Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
			Set Max Health(Event Player, 20 / Max Health(Event Player) * 100);
			Add Health Pool To Player(Event Player, Health, 180, True, True);
			Call Subroutine(commonSub);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
	}
}

rule("Winston Grab")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Event Player.survivorSpecificVariable == Null;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Is Alive(Player Closest To Reticle(Event Player, Team 2)) == True;
		Hero Of(Player Closest To Reticle(Event Player, Team 2)) != Hero(Winston);
		Player Closest To Reticle(Event Player, Team 2).winstonGrab == False;
		Is In Line of Sight(Event Player, Player Closest To Reticle(Event Player, Team 2), Barriers Do Not Block LOS) == True;
		Is In View Angle(Event Player, Player Closest To Reticle(Event Player, Team 2), 20) == True;
		Distance Between(Event Player, Player Closest To Reticle(Event Player, Team 2)) <= 6;
	}

	actions
	{
		"Winston's grab is very picky, but once done will make sure the player is on top of him, and hacked to prevent weird ability glitches (or exploits)."
		Set Ability Cooldown(Event Player, Button(Ability 2), 2);
		If(Ability Cooldown(Event Player, Button(Ability 1)) < 2);
			Set Ability Cooldown(Event Player, Button(Ability 1), 2);
		End;
		Event Player.survivorSpecificVariable = Player Closest To Reticle(Event Player, Team 2);
		Wait(0.100, Ignore Condition);
		Event Player.survivorSpecificVariable.throwingPlayer = Event Player;
		Attach Players(Event Player.survivorSpecificVariable, Event Player, Vector(0, 2, 0));
		Event Player.survivorSpecificVariable.winstonGrab = True;
		Set Status(Event Player.survivorSpecificVariable, Null, Hacked, 9999);
		Small Message(Event Player.survivorSpecificVariable, Custom String("{0} {1}: {2}", Hero Icon String(Hero(Winston)), Event Player,
			Global.stringWinstonGrab));
	}
}

rule("Winston Throw")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Event Player.survivorSpecificVariable != Null;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Event Player.survivorSpecificVariable.winstonGrab == True;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Ability 2), 5);
		Wait(0.100, Ignore Condition);
		Event Player.survivorSpecificVariable.throwingPlayer = Event Player;
		Detach Players(Event Player.survivorSpecificVariable);
		Event Player.survivorSpecificVariable.winstonGrab = False;
		Clear Status(Event Player.survivorSpecificVariable, Hacked);
		Apply Impulse(Event Player.survivorSpecificVariable, Facing Direction Of(Event Player), 40, To World, Cancel Contrary Motion);
		Event Player.survivorSpecificVariable = Null;
	}
}

rule("Winston Grab Clear Up")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Event Player.survivorSpecificVariable != Null;
		(!Entity Exists(Event Player.survivorSpecificVariable) || Is Dead(Event Player.survivorSpecificVariable)) == True;
	}

	actions
	{
		"In case something weird happens, this rule exists to clear up the variables so the ability doesn't get soft locked."
		Detach Players(Event Player.survivorSpecificVariable);
		Event Player.survivorSpecificVariable.winstonGrab = False;
		Clear Status(Event Player.survivorSpecificVariable, Hacked);
		Event Player.survivorSpecificVariable = Null;
	}
}

rule("Winston Player Escape")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Event Player.survivorSpecificVariable != Null;
		Entity Exists(Event Player.survivorSpecificVariable) == True;
		Is Alive(Event Player.survivorSpecificVariable) == True;
		Is Button Held(Event Player.survivorSpecificVariable, Button(Jump)) == True;
	}

	actions
	{
		"Not everyone wants to be captive to Winston, or trolled. This exists to allow them to escape. Since there is a cooldown for the grab, this should be enough for them to get away from a troll."
		Detach Players(Event Player.survivorSpecificVariable);
		Event Player.survivorSpecificVariable.throwingPlayer = Null;
		Event Player.survivorSpecificVariable.winstonGrab = False;
		Clear Status(Event Player.survivorSpecificVariable, Hacked);
		Event Player.survivorSpecificVariable = Null;
	}
}

rule("Set Winston Leap Cooldown")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		"To counter balancing patches."
		Set Ability Cooldown(Event Player, Button(Ability 1), 9);
	}
}

rule("Tracer Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Is Game In Progress || Is Waiting For Players) == True;
		Has Spawned(Event Player) == True;
		Event Player.lateJoin == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(Hero Of(Event Player) != Event Player.prevHero || Event Player.prevHero == Null);
			Call Subroutine(playerReset);
			Wait(0.100, Ignore Condition);
			Create HUD Text(Event Player, Custom String("{0}\n{1}", Custom String("{0}: {1}", Ability Icon String(Hero(Tracer), Button(
				Ability 1)), Custom String("{0} {1}", Round To Integer(Ability Charge(Event Player, Button(Ability 1)), Up),
				Global.stringCharges)), Custom String("{0}: {1}", Ability Icon String(Hero(Tracer), Button(Ability 2)), Custom String(
				"{0} {1}", Round To Integer(Ability Cooldown(Event Player, Button(Ability 2)), Up), Global.stringSec))), Null, Null, Left, 0,
				Color(Orange), Null, Null, Visible To and String, Default Visibility);
			Modify Global Variable At Index(hudIDs, Slot Of(Event Player), Append To Array, Last Text ID);
			Create Effect(Event Player, Ring, Color(Orange), Update Every Frame(Position Of(Event Player)), 6, Visible To Position and Radius);
			Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
			Set Max Health(Event Player, 100 / Max Health(Event Player) * 100);
			Call Subroutine(commonSub);
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
	}
}

rule("Tracer Team Warp")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		"Tracer can teleport people with her when she jukes Reaper out. She doesn't teleport people held by Winston since they will be teleported when he is."
		Event Player.survivorSpecificVariable = Filtered Array(All Players(Team 2), Distance Between(Event Player, Current Array Element)
			<= 6 && Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)
			&& Current Array Element != Event Player && Current Array Element.winstonGrab == False);
	}
}

rule("Tracer Team Warp II")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Tracer;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == False;
	}

	actions
	{
		Event Player.survivorSpecificVariable2 = False;
		For Player Variable(Event Player, survivorSpecificVariable2, 0, Count Of(Event Player.survivorSpecificVariable), 1);
			Event Player.survivorSpecificVariable[Event Player.survivorSpecificVariable2].throwingPlayer = Event Player;
			Play Effect(All Players(All Teams), Good Explosion, Color(Orange),
				Event Player.survivorSpecificVariable[Event Player.survivorSpecificVariable2], 2);
			"This wait ensures that the orange puff effect above plays in the location prior to teleport."
			Wait(0.100, Ignore Condition);
			Teleport(Event Player.survivorSpecificVariable[Event Player.survivorSpecificVariable2], Event Player);
			Clear Status(Event Player.survivorSpecificVariable[Event Player.survivorSpecificVariable2], Burning);
			Small Message(Event Player.survivorSpecificVariable[Event Player.survivorSpecificVariable2], Custom String("{0} {1}: {2}",
				Hero Icon String(Hero(Tracer)), Event Player, Global.stringTracerTeleportMessage));
		End;
		"This makes sure that the cooldown is always 28 despite Overwatch balance updates."
		Set Ability Cooldown(Event Player, Button(Ability 2), 28);
	}
}

rule("Wrecking Ball Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Is Game In Progress || Is Waiting For Players) == True;
		Has Spawned(Event Player) == True;
		Event Player.lateJoin == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(Hero Of(Event Player) != Event Player.prevHero || Event Player.prevHero == Null);
			Call Subroutine(playerReset);
			Wait(0.100, Ignore Condition);
			Create HUD Text(Event Player, Custom String("{0}\n{1}", Custom String("{0}: {1}", Ability Icon String(Hero(Wrecking Ball), Button(
				Ability 2)), Custom String("{0} {1}", Round To Integer(Ability Cooldown(Event Player, Button(Ability 2)), Up),
				Global.stringSec)), Custom String("{0}: {1}", Ability Icon String(Hero(Wrecking Ball), Button(Ultimate)), Custom String("{0}%",
				Round To Integer(Ultimate Charge Percent(Event Player), Up)))), Null, Null, Left, 0, Color(Turquoise), Null, Null,
				Visible To and String, Default Visibility);
			Modify Global Variable At Index(hudIDs, Slot Of(Event Player), Append To Array, Last Text ID);
			Set Max Health(Event Player, 50 / Max Health(Event Player) * 100);
			Add Health Pool To Player(Event Player, Health, 150, True, True);
			Call Subroutine(commonSub);
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
	}
}

rule("Wrecking Ball Respawn")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		Set Status(Event Player, Null, Hacked, 0.016);
	}
}

rule("Wrecking Ball Push Back")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		First Of(Players In Slot(0, Team 1).survivorSpecificVariable) == False;
		Is Using Ability 1(Players In Slot(0, Team 1)) == False;
		Is In Line of Sight(Event Player, Players In Slot(0, Team 1), Barriers Do Not Block LOS) == True;
		Distance Between(Event Player, Players In Slot(0, Team 1)) <= 7;
	}

	actions
	{
		"Wrecking Ball can push back Reaper even in wraith form."
		Apply Impulse(Players In Slot(0, Team 1), Direction Towards(Position Of(Event Player), Eye Position(Players In Slot(0, Team 1))),
			20, To World, Cancel Contrary Motion);
		Wait(0.050, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Wrecking Ball Mine Stun")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Wrecking Ball;
	}

	actions
	{
		"If Reaper hits a mine, he is stunned."
		Set Status(Victim, Null, Knocked Down, 2);
	}
}

rule("Force Field Cooldown")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Wrecking Ball;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 2)) > 0;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		"To counter balancing patches."
		Set Ability Cooldown(Event Player, Button(Ability 2), 25);
	}
}

rule("Hanzo Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Is Game In Progress || Is Waiting For Players) == True;
		Has Spawned(Event Player) == True;
		Event Player.lateJoin == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(Hero Of(Event Player) != Event Player.prevHero || Event Player.prevHero == Null);
			Call Subroutine(playerReset);
			Wait(0.100, Ignore Condition);
			Event Player.survivorSpecificVariable3 = Empty Array;
			Create HUD Text(Event Player, Custom String("{0}\n{1}", Custom String("{0}: {1}", Ability Icon String(Hero(Winston), Button(
				Ability 1)), Custom String("{0} {1}", Round To Integer(Ability Cooldown(Event Player, Button(Jump)), Up), Global.stringSec)),
				Custom String("{0}: {1}", Ability Icon String(Hero(Hanzo), Button(Jump)), Custom String("{0} {1}", Round To Integer(
				Ability Cooldown(Event Player, Button(Ability 2)), Up), Global.stringSec))), Null, Null, Left, 0, Color(Blue), Null, Null,
				Visible To and String, Default Visibility);
			Modify Global Variable At Index(hudIDs, Slot Of(Event Player), Append To Array, Last Text ID);
			Create Icon(Entity Exists(Players In Slot(0, Team 1)) && Is In Line of Sight(Event Player, Players In Slot(0, Team 1),
				Barriers Do Not Block LOS) && Is In View Angle(Event Player, Players In Slot(0, Team 1), 105) && Distance Between(Event Player,
				Players In Slot(0, Team 1)) <= Global.fogDistance + 10 && Is Alive(Event Player) && Is Alive(Players In Slot(0, Team 1))
				&& First Of(Players In Slot(0, Team 1).survivorSpecificVariable) == False ? All Players(Team 2) : Empty Array, Players In Slot(
				0, Team 1), Eye, Visible To and Position, Color(Red), True);
			Modify Global Variable At Index(iconIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
			Create Icon(Entity Exists(Players In Slot(2, Team 1)) && Is In Line of Sight(Event Player, Players In Slot(2, Team 1),
				Barriers Do Not Block LOS) && Is In View Angle(Event Player, Players In Slot(2, Team 1), 105) && Distance Between(Event Player,
				Players In Slot(2, Team 1)) <= Global.fogDistance + 10 && Is Alive(Event Player) && Is Alive(Players In Slot(2, Team 1))
				&& First Of(Players In Slot(2, Team 1).survivorSpecificVariable) == False ? All Players(Team 2) : Empty Array, Players In Slot(
				2, Team 1), Eye, Visible To and Position, Color(Red), True);
			Modify Global Variable At Index(iconIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
			Set Max Health(Event Player, 200 / Max Health(Event Player) * 100);
			Create Effect(Event Player, Bad Aura, Color(Black), Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
				Event Player) * (Global.fogDistance + 10)), 1000, Visible To Position and Radius);
			Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
			Create Effect(Event Player, Bad Aura, Color(Black), Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
				Event Player) * (Global.fogDistance + 11)), 1000, Visible To Position and Radius);
			Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
			Create Effect(Event Player, Bad Aura, Color(Black), Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
				Event Player) * (Global.fogDistance + 12)), 1000, Visible To Position and Radius);
			Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
			Create Effect(Event Player, Bad Aura, Color(Black), Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
				Event Player) * (Global.fogDistance + 10) * -1), 1000, Visible To Position and Radius);
			Modify Global Variable At Index(effectIDs, Slot Of(Event Player), Append To Array, Last Created Entity);
			Call Subroutine(commonSub);
	}
}

rule("Hanzo Wall Climbing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Is On Wall(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Event Player.survivorSpecificVariable == False;
	}

	actions
	{
		Event Player.survivorSpecificVariable = True;
	}
}

rule("Hanzo Wall Climb End")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Is On Wall(Event Player) == False;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Event Player.survivorSpecificVariable == True;
	}

	actions
	{
		"Hanzo's wall climb is put on a cooldown. These rules check and correct any wall climbing during cooldown."
		Set Ability Cooldown(Event Player, Button(Ability 2), 10);
		Event Player.survivorSpecificVariable = False;
	}
}

rule("Hanzo Wall Climb Prevention")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Is On Wall(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) > 0;
	}

	actions
	{
		Set Status(Event Player, Null, Hacked, 0.200);
	}
}

rule("Hanzo Leap Cooldown")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Jump)) > 0;
	}

	actions
	{
		"To counter balancing patches."
		Set Ability Cooldown(Event Player, Button(Jump), 5);
	}
}

rule("Symmetra Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Symmetra;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		(Is Game In Progress || Is Waiting For Players) == True;
		Has Spawned(Event Player) == True;
		Event Player.lateJoin == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(Hero Of(Event Player) != Event Player.prevHero || Event Player.prevHero == Null);
			Call Subroutine(playerReset);
			Wait(0.100, Ignore Condition);
			Create HUD Text(Event Player, Custom String("{0}\n{1}", Custom String("{0}: {1}", Ability Icon String(Hero(Symmetra), Button(
				Ability 1)), Custom String("{0} {1}", Round To Integer(Ability Charge(Event Player, Button(Ability 1)), Up),
				Global.stringCharges)), Custom String("{0}: {1}", Ability Icon String(Hero(Symmetra), Button(Ability 2)), Custom String(
				"{0} {1}", Round To Integer(Ability Cooldown(Event Player, Button(Ability 2)), Up), Global.stringSec))), Null, Null, Left, 0,
				Color(Sky Blue), Null, Null, Visible To and String, Default Visibility);
			Modify Global Variable At Index(hudIDs, Slot Of(Event Player), Append To Array, Last Text ID);
			Set Max Health(Event Player, 20 / Max Health(Event Player) * 100);
			Add Health Pool To Player(Event Player, Health, 180, True, True);
			Call Subroutine(commonSub);
	}
}

rule("Teleporter Ability Cooldown")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Symmetra;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 2)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Ability 2), 30);
		"because her turret cooldown is still pretty high, and instead of introducing a spam turret meta, we just give her some room to prepare a new defense."
		Set Ability Charge(Event Player, Button(Ability 1), 3);
	}
}

rule("Reaper Setup")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	actions
	{
		Start Modifying Hero Voice Lines(Event Player, -20, True);
		Stop Forcing Player Outlines(All Players(Team 2), Event Player);
		Enable Nameplates(All Players(Team 2), Event Player);
		Set Ability 2 Enabled(Event Player, False);
		Set Primary Fire Enabled(Event Player, False);
		Start Scaling Player(Event Player, 1.300, True);
		Start Damage Modification(Event Player, All Players(Team 2), 1, Receivers Damagers and Damage Percent);
		Disable Hero HUD(Event Player);
		Start Heal Over Time(Event Player, Event Player, 9999, 1000);
		Event Player.survivorSpecificVariable5 = Vector(0, 0, 0);
		"There is a position always tracked for the orb cursor. Since only the player needs to see it, this only runs for the player."
		If(!Is Dummy Bot(Event Player));
			Create Dummy Bot(Hero(Widowmaker), Team 1, 1, Position Of(Event Player), Vector(0, 0, 0));
	}
}

rule("Reaper HUD and Effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create In-World Text(Entity Exists(Players In Slot(2, Team 1)) ? All Players(Team 1) : Empty Array, Global.stringGhost,
			Players In Slot(2, Team 1), 1, Do Not Clip, Visible To Position and String, Color(Purple), Default Visibility);
		Create HUD Text(Players In Slot(0, Team 1), Custom String("{0}: {1} {2}", Ability Icon String(Hero(Reaper), Button(Ability 1)),
			Round To Integer(Ability Cooldown(Players In Slot(0, Team 1), Button(Ability 1)), Up), Global.stringSec), Null, Null, Left, 1,
			Color(Purple), Null, Null, Visible To and String, Default Visibility);
		Create HUD Text(Players In Slot(0, Team 1), Custom String("{0}: {1} {2}", Ability Icon String(Hero(Reaper), Button(Ability 2)),
			Round To Integer(Ability Cooldown(Players In Slot(0, Team 1), Button(Ability 2)), Up), Global.stringSec), Null, Null, Left,
			1.100, Color(Purple), Null, Null, Visible To and String, Default Visibility);
		Create HUD Text(Players In Slot(0, Team 1), Custom String("{0}: ∞", Ability Icon String(Hero(Reaper), Button(Melee))), Null, Null,
			Left, 1.600, Color(Purple), Null, Null, Visible To and String, Default Visibility);
		Create HUD Text(Players In Slot(0, Team 1), Custom String("{0}: {1} {2}", Ability Icon String(Hero(Echo), Button(Ultimate)),
			Round To Integer(Players In Slot(0, Team 1).survivorSpecificVariable3, Up), Global.stringSec), Null, Null, Left, 1.300, Color(
			Purple), Null, Null, Visible To and String, Default Visibility);
		Create HUD Text(Players In Slot(0, Team 1), Custom String("{0}: {1} {2}", Icon String(Recycle), Round To Integer(Players In Slot(0,
			Team 1).survivorSpecificVariable4, Up), Global.stringSec), Null, Null, Left, 1.400, Color(Purple), Null, Null,
			Visible To and String, Default Visibility);
		Create Effect(Players In Slot(0, Team 1).survivorSpecificVariable[1] == False ? Players In Slot(0, Team 1) : Empty Array, Orb,
			Color(Gray), Update Every Frame(Ray Cast Hit Position(Eye Position(Players In Slot(0, Team 1)), Facing Direction Of(
			Players In Slot(0, Team 1)) * 1000 + Eye Position(Players In Slot(0, Team 1)), Null, All Players(All Teams), False)), 2,
			Visible To Position and Radius);
		Create In-World Text(First Of(Players In Slot(0, Team 1).survivorSpecificVariable) == False ? Players In Slot(0, Team 1)
			: Empty Array, Input Binding String(Button(Secondary Fire)), Update Every Frame(Ray Cast Hit Position(Eye Position(
			Players In Slot(0, Team 1)), Facing Direction Of(Players In Slot(0, Team 1)) * 1000 + Eye Position(Players In Slot(0, Team 1)),
			Null, All Players(All Teams), False)), 1, Clip Against Surfaces, Visible To Position and String, Color(White),
			Default Visibility);
		Create In-World Text(Players In Slot(0, Team 1).survivorSpecificVariable[1] == False && First Of(Players In Slot(0, Team 1)
			.survivorSpecificVariable) == True ? Players In Slot(0, Team 1) : Empty Array, Custom String("{0} {1} | {2}",
			Global.stringReaperTeleport, Input Binding String(Button(Primary Fire)), Custom String("{0} {1}", Input Binding String(Button(
			Secondary Fire)), Global.stringReaperTeleportGhost)), Update Every Frame(Ray Cast Hit Position(Eye Position(Players In Slot(0,
			Team 1)), Facing Direction Of(Players In Slot(0, Team 1)) * 1000 + Eye Position(Players In Slot(0, Team 1)), Null, All Players(
			All Teams), False)), 1, Do Not Clip, Visible To Position and String, Color(White), Default Visibility);
		Create HUD Text(Players In Slot(0, Team 1).hideInfo == False ? Players In Slot(0, Team 1) : Empty Array, Null, Null, Custom String(
			" \n{0}\n\n{1}", Global.stringReaperTitle, Custom String("{0}\n{1}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(
			Reaper), Button(Ability 1)), Input Binding String(Button(Ability 1)), Global.stringReaperAbility1), Custom String(
			"{0} {1}: {2}", Ability Icon String(Hero(Reaper), Button(Ability 2)), Input Binding String(Button(Ability 2)),
			Global.stringReaperAbility2))), Left, 1.800, Null, Null, Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Players In Slot(0, Team 1).hideInfo == False ? Players In Slot(0, Team 1) : Empty Array, Null, Null, Custom String(
			"{0}\n{1}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(Echo), Button(Ultimate)), Input Binding String(Button(
			Secondary Fire)), Global.stringReaperAbility3), Custom String("{0} {1}: {2}", Icon String(Recycle), Input Binding String(
			Button(Ultimate)), Global.stringReaperAbility4)), Left, 1.810, Null, Null, Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Players In Slot(0, Team 1).hideInfo == False ? Players In Slot(0, Team 1) : Empty Array, Null, Null, Custom String(
			"{0} {1}: {2}", Ability Icon String(Hero(Reaper), Button(Melee)), Input Binding String(Button(Melee)),
			Global.stringReaperAbility5), Left, 1.820, Null, Null, Color(White), Visible To and String, Default Visibility);
	}
}

rule("Reaper Spawn")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Is Game In Progress || Is Waiting For Players) == True;
		Is Alive(Players In Slot(0, Team 1)) == True;
		Has Spawned(Players In Slot(0, Team 1)) == True;
		Players In Slot(0, Team 1).hasSpawned == False;
	}

	actions
	{
		Wait(0.500, Ignore Condition);
		Set Ability Cooldown(Players On Hero(Hero(Reaper), All Teams), Button(Ability 1), 0);
		If(Is Game In Progress);
			Players In Slot(0, Team 1).hasSpawned = True;
	}
}

rule("Reaper Cleanup Before Game Start")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Assembling Heroes == True;
	}

	actions
	{
		"This cleans up the dummy bots Reaper was using before the match and teleportation variables."
		Destroy Dummy Bot(Team 1, 1);
		Destroy Dummy Bot(Team 1, 2);
		"This teleport clean up is specifically for the pre-match."
		Players In Slot(0, Team 1).survivorSpecificVariable[0] = False;
		Players In Slot(0, Team 1).survivorSpecificVariable[1] = False;
		Enable Movement Collision With Environment(Players In Slot(0, Team 1));
		Clear Status(Players In Slot(0, Team 1), Phased Out);
		Stop Chasing Player Variable(Players In Slot(0, Team 1), survivorSpecificVariable2);
		Stop Forcing Player Position(Players In Slot(0, Team 1));
		Set Ability 1 Enabled(Players In Slot(0, Team 1), True);
		Set Melee Enabled(Players In Slot(0, Team 1), True);
		Set Ability Cooldown(Players In Slot(0, Team 1), Button(Ability 2), 7);
		Set Invisible(Players In Slot(0, Team 1), None);
	}
}

rule("Teleport (Start Teleport)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ability 2)) == True;
		First Of(Event Player.survivorSpecificVariable) == False;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Has Status(Event Player, Hacked) == False;
		Has Status(Event Player, Frozen) == False;
		Has Status(Event Player, Stunned) == False;
		Has Status(Event Player, Knocked Down) == False;
		Has Status(Event Player, Asleep) == False;
		Event Player.survivorSpecificVariable[1] == False;
		Is Button Held(Event Player, Button(Primary Fire)) == False;
	}

	actions
	{
		"The beginning of Reaper's unique teleport."
		Set Ability Cooldown(Event Player, Button(Ability 2), 2);
		Wait(0.100, Ignore Condition);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Black), Position Of(Event Player), 3);
		Set Ability 1 Enabled(Event Player, False);
		Set Melee Enabled(Event Player, False);
		Set Invisible(Event Player, All);
		Set Status(Event Player, Null, Phased Out, 9999);
		Disable Movement Collision With Environment(Event Player, True);
		Start Forcing Player Position(Event Player, Event Player.survivorSpecificVariable2, True);
		Event Player.survivorSpecificVariable[0] = True;
		Event Player.survivorSpecificVariable2 = Position Of(Event Player);
		Event Player.survivorSpecificVariable[2] = Position Of(Event Player);
		Chase Player Variable At Rate(Event Player, survivorSpecificVariable2, Update Every Frame(
			Event Player.survivorSpecificVariable[2]), 5 * Distance Between(Event Player.survivorSpecificVariable[2],
			Event Player.survivorSpecificVariable2), Destination and Rate);
	}
}

rule("Teleport (Rise from Ground)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		First Of(Event Player.survivorSpecificVariable) == True;
		Event Player.survivorSpecificVariable[1] == False;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		"eventPlayer.theGround = raycast(eventPlayer.getEyePosition(), eventPlayer.getFacingDirection() * 1000 + eventPlayer.getEyePosition(), null, eventPlayer, false).getHitPosition()\r\n\nThis check is applied due to an exploit on Eichenwalde."
		Event Player.survivorSpecificVariable[3] = Ray Cast Hit Position(Eye Position(Event Player), Facing Direction Of(Event Player)
			* 1000 + Eye Position(Event Player), Null, Event Player, False);
		Disable Movement Collision With Environment(Event Player, True);
		Event Player.survivorSpecificVariable[4] = Event Player.survivorSpecificVariable[3] + Vector(0, -4, 0);
		Event Player.survivorSpecificVariable2 = Event Player.survivorSpecificVariable[4];
		Chase Player Variable At Rate(Event Player, survivorSpecificVariable2, Event Player.survivorSpecificVariable[3], 2,
			Destination and Rate);
		Event Player.survivorSpecificVariable[1] = True;
		Wait(0.250, Ignore Condition);
		Set Invisible(Event Player, None);
		"This message serves as a warning for survivors that he is teleporting nearby."
		Small Message(Filtered Array(All Players(All Teams), Distance Between(Event Player, Current Array Element) <= 15), Custom String(
			"{0} {1}: {2}", Hero Icon String(Hero(Reaper)), Event Player, Global.stringReaperTeleportSpawn));
	}
}

rule("Teleport (Clean up Teleport)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Event Player.survivorSpecificVariable2 == Event Player.survivorSpecificVariable[3];
		Event Player.survivorSpecificVariable[1] == True;
	}

	actions
	{
		"Once he has finished rising, this subroutine will clean up the variables and other adjustments made."
		Event Player.survivorSpecificVariable[0] = False;
		Event Player.survivorSpecificVariable[1] = False;
		Enable Movement Collision With Environment(Event Player);
		Clear Status(Event Player, Phased Out);
		Stop Chasing Player Variable(Event Player, survivorSpecificVariable2);
		Stop Forcing Player Position(Event Player);
		Set Ability 1 Enabled(Event Player, True);
		Set Melee Enabled(Event Player, True);
		Set Ability Cooldown(Event Player, Button(Ability 2), 7);
		"This is to prevent out of bounds teleports. The game waits 0.2 sec to ensure that the out of bounds is really out of bounds."
		Wait(1, Ignore Condition);
		If(Distance Between(Nearest Walkable Position(Position Of(Event Player)), Position Of(Event Player)) >= 5 && !Is Dummy Bot(
			Event Player));
			Teleport(Event Player, Nearest Walkable Position(Position Of(Event Player)));
			Play Effect(All Players(All Teams), Bad Explosion, Color(Black), Position Of(Event Player), 3);
			Set Status(Event Player, Null, Stunned, 2);
			Small Message(Event Player, Global.stringInvalidPosition);
	}
}

rule("Move Player During Teleport")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		First Of(Event Player.survivorSpecificVariable) == True;
		Event Player.survivorSpecificVariable[1] == False;
	}

	actions
	{
		If(X Component Of(Throttle Of(Event Player)) != 0 || Z Component Of(Throttle Of(Event Player)) != 0);
			Event Player.survivorSpecificVariable[2] += Direction From Angles(Horizontal Angle From Direction(Throttle Of(Event Player))
				+ Horizontal Facing Angle Of(Event Player), 0) * Square Root(X Component Of(Throttle Of(Event Player)) * X Component Of(
				Throttle Of(Event Player)) + Z Component Of(Throttle Of(Event Player)) * Z Component Of(Throttle Of(Event Player)));
		End;
		If(Is Button Held(Event Player, Button(Jump)));
			Event Player.survivorSpecificVariable[2] += Vector(0, 0.700, 0);
		End;
		If(Is Button Held(Event Player, Button(Crouch)));
			Event Player.survivorSpecificVariable[2] += Vector(0, -0.700, 0);
		End;
		Wait(0.050, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Wraith (Setup No Clip)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"With wraith form Reaper can no clip through walls."
		Disable Movement Collision With Environment(Event Player, False);
		Set Melee Enabled(Event Player, False);
		Set Move Speed(Event Player, 80);
	}
}

rule("Wraith (Disable Clipping)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Enable Movement Collision With Environment(Event Player);
		Set Move Speed(Event Player, 100);
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Ability 1), 12);
		"This is to fix wraith abuse. A technique used is to wraith to get the speed-boost, then while reverting, the player is given a window of opportunity to melee while still be invincible.\r\n\nThis wait prevents that."
		Wait(0.300, Ignore Condition);
		Set Melee Enabled(Event Player, True);
	}
}

rule("Spawn Ghost (Create Dummy Bot)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Is Using Ability 1(Event Player) == False;
		Event Player.survivorSpecificVariable3 == 0;
		Event Player.survivorSpecificVariable[1] == False;
	}

	actions
	{
		Create Dummy Bot(Hero(Reaper), Team 1, 2, Vector(0, -4, 0) + Ray Cast Hit Position(Eye Position(Event Player), Facing Direction Of(
			Event Player) * 1000 + Eye Position(Event Player), Null, Event Player, False), Direction From Angles(
			Horizontal Facing Angle Of(Event Player), 0));
		Event Player.survivorSpecificVariable3 = 10;
		Chase Player Variable At Rate(Event Player, survivorSpecificVariable3, 0, 1, Destination and Rate);
		Small Message(Filtered Array(All Players(All Teams), Distance Between(Ray Cast Hit Position(Eye Position(Event Player),
			Facing Direction Of(Event Player) * 1000 + Eye Position(Event Player), Null, Event Player, False), Current Array Element)
			<= 15), Custom String("{0} {1}: {2}", Hero Icon String(Hero(Reaper)), Event Player, Global.stringReaperTeleportSpawn));
	}
}

rule("Ghost Setup (Dummy Bot Setup)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Slot Of(Event Player) == 2;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		"This dummy bot is a setup and forget thing. Once it spawns it will automatically run forwards, sometimes changing direction and wraithing if a survivor is within view."
		Event Player.survivorSpecificVariable[0] = True;
		Start Forcing Throttle(Event Player, 1, 1, 0, 1, 0, 1);
		"The following rules are to get it read for the Rise from Ground rule."
		Disable Movement Collision With Environment(Event Player, True);
		Event Player.survivorSpecificVariable2 = Position Of(Event Player);
		Event Player.survivorSpecificVariable[3] = Position Of(Event Player) + Vector(0, 4, 0);
		Start Forcing Player Position(Event Player, Event Player.survivorSpecificVariable2, True);
		Wait(1, Ignore Condition);
		Start Forcing Player Outlines(Event Player, All Players(Team 2), False, Color(White), Default);
		Disable Nameplates(Event Player, All Players(All Teams));
		Chase Player Variable At Rate(Event Player, survivorSpecificVariable2, Event Player.survivorSpecificVariable[3], 2,
			Destination and Rate);
		Event Player.survivorSpecificVariable[1] = True;
		"Before the ghost fully emerges and is fully spawned, effects are set up."
		Wait(0.500, Ignore Condition);
		Set Status(Event Player, Null, Phased Out, 9999);
		Disable Movement Collision With Environment(Event Player, False);
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Purple), Default);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
	}
}

rule("Ghost Died (Destroy Bot if dead)")
{
	event
	{
		Player Died;
		Team 1;
		Slot 2;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Hero Of(Event Player) == Hero(Reaper);
	}

	actions
	{
		"If the dummy bot somehow dies, it is deleted so it doesn't just respawn randomly."
		Destroy Dummy Bot(Team 1, 2);
	}
}

rule("Ghost Spawn CD Reset")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Event Player.survivorSpecificVariable3 == 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, survivorSpecificVariable3);
	}
}

rule("Ghost Teleport")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is In Air(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
		First Of(Event Player.survivorSpecificVariable) == False;
		Event Player.survivorSpecificVariable[1] == False;
	}

	actions
	{
		"The dummy bot tries to prevent suicide. If it starts falling it is assumed that it will die (whether that is true or not), so it teleports to the closest area and continues it's path."
		Wait(0.500, Abort When False);
		Teleport(Event Player, Nearest Walkable Position(Position Of(Event Player)));
		Set Facing(Event Player, Vector(Random Real(-1, -0.100), 0, Random Real(-1, -0.100)), To Player);
	}
}

rule("Ghost Chase")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		First Of(Event Player.survivorSpecificVariable) == False;
		Event Player.survivorSpecificVariable[1] == False;
		Is True For Any(Players in View Angle(Event Player, Team 2, 30), Is In Line of Sight(Eye Position(Event Player), Eye Position(
			Current Array Element), Barriers Do Not Block LOS)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Hero Of(Event Player) == Hero(Reaper);
	}

	actions
	{
		"This is here to scare the player into reacting."
		Start Holding Button(Event Player, Button(Ability 1));
		Wait(0.016, Ignore Condition);
		Stop Holding Button(Event Player, Button(Ability 1));
		Set Facing(Event Player, Direction Towards(Event Player, Player Closest To Reticle(Event Player, Team 2)), To World);
		"This is here to provide info for decoy swap. If the decoy sees a player and starts chasing, the Reaper may want to swap position and confuse the survivor, or take advantage of them not reacting."
		Small Message(Players In Slot(0, Team 1), Custom String("{0} {1}: {2}", Hero Icon String(Hero(Reaper)), Global.stringGhost,
			Global.stringChase));
	}
}

rule("Restore No-Clip after Rising")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		First Of(Event Player.survivorSpecificVariable) == False;
		Event Player.survivorSpecificVariable[1] == False;
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		"The decoy is always no clipped. It is both easier for it to roam and also a sign for survivors to note."
		Disable Movement Collision With Environment(Event Player, False);
		Set Status(Event Player, Null, Phased Out, 9999);
	}
}

rule("Ghost Swap (Dummy Bot Swap Positions)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		First Of(Event Player.survivorSpecificVariable) == False;
		Entity Exists(Players In Slot(2, Team 1)) == True;
		Event Player.survivorSpecificVariable4 == 0;
		Is Using Ability 1(Event Player) == False;
		Has Status(Event Player, Hacked) == False;
		Has Status(Event Player, Frozen) == False;
		Has Status(Event Player, Stunned) == False;
		Has Status(Event Player, Knocked Down) == False;
		Has Status(Event Player, Asleep) == False;
	}

	actions
	{
		"Ghost swap ensures that, if done right, it is unnoticeable to the survivor. This means that the change has to be instant (so position variables have to be stored) and they are facing the same direction (another variable stored)"
		Event Player.survivorSpecificVariable[5] = Position Of(Players In Slot(2, Team 1));
		Event Player.survivorSpecificVariable[6] = Facing Direction Of(Players In Slot(2, Team 1));
		Teleport(Players In Slot(2, Team 1), Event Player);
		Set Facing(Players In Slot(2, Team 1), Facing Direction Of(Event Player), To World);
		Wait(0.100, Ignore Condition);
		"In case the swap was in mid air, the decoy will retreat to NWP."
		Teleport(Event Player, Nearest Walkable Position(Event Player.survivorSpecificVariable[5]));
		Set Facing(Event Player, Event Player.survivorSpecificVariable[6], To World);
		Event Player.survivorSpecificVariable4 = 20;
		Chase Player Variable At Rate(Event Player, survivorSpecificVariable4, 0, 1, Destination and Rate);
	}
}

rule("Ghost Swap Cooldown Reset")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Event Player.survivorSpecificVariable4 == 0;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, survivorSpecificVariable4);
	}
}

rule("Reaper Melee on Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		First Of(Event Player.survivorSpecificVariable) == False;
	}

	actions
	{
		"As a community request, the melee can also be done on primary fire (though the game will still refer for the melee button in the info)."
		Start Holding Button(Event Player, Button(Melee));
		Wait(0.016, Ignore Condition);
		Stop Holding Button(Event Player, Button(Melee));
	}
}

rule("Reaper Melee Stun")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Reaper;
	}

	conditions
	{
		Is Meleeing(Event Player) == True;
	}

	actions
	{
		"If Reaper lands a hit, he is stunned to give the victim time to reposition."
		Set Status(Event Player, Null, Stunned, 3);
		Small Message(Event Player, Global.stringReaperHit);
	}
}

rule("Reaper died")
{
	event
	{
		Player Died;
		Team 1;
		Reaper;
	}

	actions
	{
		Play Effect(All Players(All Teams), Bad Explosion, Color(Black), Position Of(Event Player), 3);
	}
}

rule("Widowmaker Spawn")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Invisible(Event Player, All);
		Start Forcing Player Position(Event Player, Vector(0, 0, 0), False);
		Wait(1, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
	}
}

rule("Initial Setup (Global Setup)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Built-In Game Mode Music;
		Disable Built-In Game Mode Announcer;
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Scoring;
		Call Subroutine(nameTagCreate);
		Global.gracePeriod = 30;
		Global.tipsEnabled = Workshop Setting Toggle(Custom String("General"), Custom String("Info Displayed by Default"), True, 0);
		Global.matchTimeMin = Workshop Setting Integer(Custom String("Time"), Custom String("Minutes"), 4, 1, 20, 0);
		Global.matchTimeSec = Workshop Setting Integer(Custom String("Time"), Custom String("Seconds"), 30, 0, 59, 0);
		Global.debugMode = Workshop Setting Toggle(Custom String("Debug Mode"), Custom String("Enabled"), False, 0);
		Global.constantMatchTime = Workshop Setting Toggle(Custom String("Time"), Custom String("Dynamic Match Time"), True, 0);
		"If debug mode is disabled, recording is also disabled to save server resources."
		Global.hudIDs = Empty Array;
		Global.effectIDs = Empty Array;
		Global.inWorldTextIDs = Empty Array;
		If(Global.debugMode);
			Create HUD Text(Host Player, Server Load Average, String("Server Load Average"), Null, Right, 10, Color(White), Color(White),
				Color(White), Visible To and String, Default Visibility);
		Else;
			Disable Inspector Recording;
	}
}

rule("Initial Setup (Per Player Setup)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Waiting For Players || Is Game In Progress) == True;
	}

	actions
	{
		Disable Hero HUD(Event Player);
		Disable Game Mode HUD(Event Player);
		Enable Death Spectate Target HUD(Event Player);
		Event Player.prevHero = Null;
		Set Respawn Max Time(Event Player, 5);
		If(Team Of(Event Player) == Team 2);
			Disable Scoreboard(Event Player);
			Disable Kill Feed(Event Player);
			Event Player.hasSpawned = False;
		End;
		If(Global.tipsEnabled == False);
			Event Player.hideInfo = True;
	}
}

rule("Pre-Match HUD & In-world Effect Creation")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Global HUD setup"
		Create HUD Text(Is Game In Progress ? All Players(All Teams) : Empty Array, Custom String("{0}: {1}", Global.stringTimeRemaining,
			Round To Integer(Match Time, Up)), Null, Null, Top, 0, Color(Orange), Null, Null, Visible To and String, Default Visibility);
		Create HUD Text(Is Game In Progress ? All Players(Team 2) : Empty Array, Null, Null, Global.stringObjectiveSurvivors, Top, -1,
			Null, Null, Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Is Game In Progress ? All Players(Team 1) : Empty Array, Null, Null, Global.stringObjectiveReaper, Top, -1, Null,
			Null, Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Custom String("Project: Phantom"), Null, Null, Right, -5, Color(Purple), Null, Null,
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Global.stringCreatorVersion, Custom String(" "), Right, -4, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Global.stringDiscord, Right, -3, Null, Null, Color(Orange),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Global.stringProject, Right, -2, Null, Null, Color(Orange),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Global.stringCode, Right, -1, Null, Null, Color(Aqua), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 2), Current Array Element.winstonGrab == True), Custom String("{0}: {1}",
			Input Binding String(Button(Jump)), Global.stringWinstonRide), Null, Null, Top, 1, Color(White), Null, Null,
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(Team 2), Null, Null, Global.stringTip, Left, 3, Null, Null, Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(All Players(Team 1), Null, Null, Global.stringTip2, Left, 4, Null, Null, Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" \n{0}", Global.stringGH), Right, -0.920, Null, Null, Color(
			Yellow), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Global.stringGHDiscord, Right, -0.910, Null, Null, Color(Yellow),
			Visible To and String, Default Visibility);
		"Late Join HUD Setup"
		Create HUD Text(Filtered Array(All Players(Team 2), Current Array Element.lateJoin == True), Global.stringLateJoin, Null, Null,
			Top, 2, Color(Yellow), Null, Null, Visible To and String, Default Visibility);
		"Show/hide info setup"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.hideInfo == True), Null, Null, Custom String(
			" \n{0} + {1}: {2}", Input Binding String(Button(Interact)), Input Binding String(Button(Crouch)), Global.stringShowInfo),
			Left, 2, Null, Null, Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.hideInfo == False), Null, Null, Custom String(
			" \n{0} + {1}: {2}", Input Binding String(Button(Interact)), Input Binding String(Button(Crouch)), Global.stringHideInfo),
			Left, 2, Null, Null, Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Is Waiting For Players ? All Players(All Teams) : Empty Array, Null, Null, Custom String("{0} ({1})",
			Global.stringWaitingGame, Host Player), Top, -1, Color(White), Color(White), Color(White), Visible To Sort Order and String,
			Default Visibility);
		"Survivor Info HUD Setup"
		Create HUD Text(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Moira)
			&& Current Array Element.hideInfo == False), Null, Null, Custom String(" \n{0}\n\n{1}", Global.stringMoiraTitle, Custom String(
			"{0}\n{1}\n{2}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(Moira), Button(Ability 1)), Input Binding String(
			Button(Ability 1)), Global.stringMoiraAbility1), Custom String("{0} {1}: {2}", Ability Icon String(Hero(Zenyatta), Button(
			Ability 1)), Input Binding String(Button(Ability 2)), Global.stringMoiraAbility2), Global.stringMoiraPassive)), Left, 1, Null,
			Null, Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Hanzo)
			&& Current Array Element.hideInfo == False), Null, Null, Custom String(" \n{0}\n\n{1}", Global.stringHanzoTitle, Custom String(
			"{0}\n{1}\n{2}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(Winston), Button(Ability 1)), Input Binding String(
			Button(Jump)), Global.stringHanzoAbility1), Custom String("{0} {1}: {2}", Ability Icon String(Hero(Hanzo), Button(Jump)),
			Input Binding String(Button(Jump)), Global.stringHanzoAbility2), Global.stringHanzoPassive)), Left, 1, Null, Null, Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Brigitte)
			&& Current Array Element.hideInfo == False), Null, Null, Custom String(" \n{0}\n\n{1}", Global.stringBrigTitle, Custom String(
			"{0}\n{1}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(Brigitte), Button(Ability 1)), Input Binding String(Button(
			Ability 1)), Global.stringBrigAbility1), Custom String("{0} {1}: {2}", Ability Icon String(Hero(Brigitte), Button(
			Secondary Fire)), Input Binding String(Button(Secondary Fire)), Global.stringBrigAbility2))), Left, 1, Null, Null, Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Wrecking Ball)
			&& Current Array Element.hideInfo == False), Null, Null, Custom String(" \n{0}\n\n{1}", Global.stringWBTitle, Custom String(
			"{0}\n{1}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(Wrecking Ball), Button(Ability 2)), Input Binding String(
			Button(Ability 2)), Global.stringWBAbility1), Custom String("{0} {1}: {2}", Ability Icon String(Hero(Wrecking Ball), Button(
			Ultimate)), Input Binding String(Button(Ultimate)), Global.stringWBAbility2))), Left, 1, Null, Null, Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Symmetra)
			&& Current Array Element.hideInfo == False), Null, Null, Custom String(" \n{0}\n\n{1}", Global.stringSymTitle, Custom String(
			"{0}\n{1}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(Symmetra), Button(Ability 1)), Input Binding String(Button(
			Ability 1)), Global.stringSymAbility1), Custom String("{0} {1}: {2}", Ability Icon String(Hero(Symmetra), Button(Ability 2)),
			Input Binding String(Button(Ability 2)), Global.stringSymAbility2))), Left, 1, Null, Null, Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Tracer)
			&& Current Array Element.hideInfo == False), Null, Null, Custom String(" \n{0}\n\n{1}", Global.stringTracerTitle,
			Custom String("{0}\n{1}\n{2}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(Tracer), Button(Ability 1)),
			Input Binding String(Button(Ability 1)), Global.stringTracerAbility1), Custom String("{0} {1}: {2}", Ability Icon String(Hero(
			Tracer), Button(Ability 2)), Input Binding String(Button(Ability 2)), Global.stringTracerAbility2),
			Global.stringTracerPassive)), Left, 1, Null, Null, Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Winston)
			&& Current Array Element.hideInfo == False), Null, Null, Custom String(" \n{0}\n\n{1}", Global.stringWinstonTitle,
			Custom String("{0}\n{1}", Custom String("{0} {1}: {2}", Ability Icon String(Hero(Winston), Button(Ability 1)),
			Input Binding String(Button(Ability 1)), Global.stringWinstonAbility1), Custom String("{0} {1}: {2}", Ability Icon String(Hero(
			Mercy), Button(Ability 2)), Input Binding String(Button(Secondary Fire)), Global.stringWinstonAbility2))), Left, 1, Null, Null,
			Color(White), Visible To and String, Default Visibility);
	}
}

rule("Nametag In World Text Setup Subroutine")
{
	event
	{
		Subroutine;
		nameTagCreate;
	}

	actions
	{
		"Nametags are disabled for Team 2 by default, so I created an alternate name tag system. Basically, when one player of team 2 is close to another team 2 player, they get to see each other's nametags."
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(0, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(0, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(0, Team 2)) && Current Array Element != Players In Slot(0, Team 2)), Players In Slot(0, Team 2),
			Players In Slot(0, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(1, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(1, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(1, Team 2)) && Current Array Element != Players In Slot(1, Team 2)), Players In Slot(1, Team 2),
			Players In Slot(1, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(2, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(2, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(2, Team 2)) && Current Array Element != Players In Slot(2, Team 2)), Players In Slot(2, Team 2),
			Players In Slot(2, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(3, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(3, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(3, Team 2)) && Current Array Element != Players In Slot(3, Team 2)), Players In Slot(3, Team 2),
			Players In Slot(3, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(4, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(4, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(4, Team 2)) && Current Array Element != Players In Slot(4, Team 2)), Players In Slot(4, Team 2),
			Players In Slot(4, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(5, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(5, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(5, Team 2)) && Current Array Element != Players In Slot(5, Team 2)), Players In Slot(5, Team 2),
			Players In Slot(5, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(6, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(6, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(6, Team 2)) && Current Array Element != Players In Slot(6, Team 2)), Players In Slot(6, Team 2),
			Players In Slot(6, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(7, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(7, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(7, Team 2)) && Current Array Element != Players In Slot(7, Team 2)), Players In Slot(7, Team 2),
			Players In Slot(7, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(8, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(8, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(8, Team 2)) && Current Array Element != Players In Slot(8, Team 2)), Players In Slot(8, Team 2),
			Players In Slot(8, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(9, Team 2), Current Array Element)
			<= 8 && Is In Line of Sight(Players In Slot(9, Team 2), Current Array Element, Barriers Do Not Block LOS) && Entity Exists(
			Players In Slot(9, Team 2)) && Current Array Element != Players In Slot(9, Team 2)), Players In Slot(9, Team 2),
			Players In Slot(9, Team 2), 1, Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(10, Team 2),
			Current Array Element) <= 8 && Is In Line of Sight(Players In Slot(10, Team 2), Current Array Element,
			Barriers Do Not Block LOS) && Entity Exists(Players In Slot(10, Team 2)) && Current Array Element != Players In Slot(10,
			Team 2)), Players In Slot(10, Team 2), Players In Slot(10, Team 2), 1, Clip Against Surfaces, Visible To Position and String,
			Color(Yellow), Default Visibility);
		Create In-World Text(Filtered Array(All Living Players(Team 2), Distance Between(Players In Slot(11, Team 2),
			Current Array Element) <= 8 && Is In Line of Sight(Players In Slot(11, Team 2), Current Array Element,
			Barriers Do Not Block LOS) && Entity Exists(Players In Slot(11, Team 2)) && Current Array Element != Players In Slot(11,
			Team 2)), Players In Slot(11, Team 2), Players In Slot(11, Team 2), 1, Clip Against Surfaces, Visible To Position and String,
			Color(Yellow), Default Visibility);
	}
}

rule("Debug Mode")
{
	event
	{
		Subroutine;
		debugMode;
	}

	actions
	{
		"A dummy bot for Reaper and Ana is created so that you can test certain stuff. They both occupy slot 0 of each team, so if you don't want them to spawn in, make sure a player is in each of those slots."
		Create Dummy Bot(Hero(Reaper), Team 1, 0, Nearest Walkable Position(Vector(0, 0, 0)), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Hanzo), Team 2, 0, Nearest Walkable Position(Vector(1000, 0, 0)), Vector(0, 0, 0));
		Wait(2, Ignore Condition);
		Damage(Last Created Entity, Null, 150);
	}
}

rule("Gamemode Setup")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		If(Global.constantMatchTime);
			If(Number Of Players(Team 2) <= 2);
				Global.dynMatchTime = 70;
			Else;
				Global.dynMatchTime = Number Of Players(Team 2) * 35;
			End;
		Else;
			Global.dynMatchTime = Global.matchTimeMin * 60 + Global.matchTimeSec;
		End;
		Set Match Time(Global.dynMatchTime);
		Big Message(All Players(Team 2), Global.stringObjectiveSurvivors);
		Big Message(All Players(Team 1), Global.stringObjectiveReaper);
		If(Global.debugMode == True);
			Call Subroutine(debugMode);
	}
}

rule("Winning Setup (Time Runs Out)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Match Time == 0;
	}

	actions
	{
		Wait(0.100, Abort When False);
		"If some living players are still alive for team 2 (that also have spawned in) when time runs out, they win, else Reaper wins. (This else statement solely exists for backup. Practically this will never be executed)."
		If(Count Of(Filtered Array(All Living Players(Team 2), Has Spawned(Current Array Element))) > 0);
			Declare Team Victory(Team 2);
		Else;
			Declare Team Victory(Team 1);
		End;
		Destroy All Dummy Bots;
	}
}

rule("Winning Setup (Reaper Kills Everyone that spawned on time)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Count Of(Filtered Array(All Living Players(Team 2), Has Spawned(Current Array Element))) == 0;
		Match Time < Global.dynMatchTime - Global.gracePeriod;
		Has Spawned(Players In Slot(0, Team 1)) == True;
	}

	actions
	{
		"If everyone is dead, Reaper wins."
		Wait(0.100, Abort When False);
		Declare Team Victory(Team 1);
		Destroy All Dummy Bots;
	}
}

rule("Winning Setup (Survivors win if Reaper does not exist)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Entity Exists(Players In Slot(0, Team 1)) == False;
		Match Time < Global.dynMatchTime - Global.gracePeriod;
	}

	actions
	{
		"Backup win condition if Reaper did not spawn in or he disconnected."
		Wait(0.100, Ignore Condition);
		Declare Team Victory(Team 2);
		Destroy All Dummy Bots;
	}
}

rule("Late Join Setup")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == False;
		Is Game In Progress == True;
		"If a player joins or did not select a character before the grace period (default match time - grace period), then he is considered a late joining player. The game does not consider him to be alive, and when he spawns he is killed immediately."
		Match Time < Global.dynMatchTime - Global.gracePeriod;
	}

	actions
	{
		Wait(0.100, Abort When False);
		Event Player.lateJoin = True;
		Disable Built-In Game Mode Respawning(Event Player);
	}
}

rule("Late Join Kill")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Event Player.lateJoin == True;
	}

	actions
	{
		Kill(Event Player, Null);
	}
}